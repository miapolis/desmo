import script "./maze.mjs"

settings @{
    viewport: @{ xmin: -18, ymin: -20, xmax: 19, ymax: 40 },
    showGrid: false,
    showXAxis: false,
    showYAxis: false,
    userLockedViewport: true
  }

gridSize = 12;
proj = 3.5;
gridOffset = 0.75;

black = rgb(0, 0, 0);
gray = rgb(200, 200, 200);

cacheCos = cos(proj / 6);
cacheSin = sin(proj / 6);

subst!(diff, a, b, a - b);
subst!(bool, v, { v: 1, 0 });

ticker @{
    handlerLatex: ds(player.movePlayer() , camera.adjustCameraToPlayer() , global.tick()),
    playing: true,
    open: true
  }

ns global {
  frame = 0;
  
  fn lerp(a, b, time) {
    (1 - time) * a + time * b
  }
  show fn delta(start, duration) {
    mod((frame - start), duration) / duration
  } @{ hidden: true }
  
  fn tick() {
    frame -> frame + 1
  }
}

ns camera {
  cameraX = 0;
  cameraY = 0;
  
  targetX = 0;
  targetY = 0;
  
  lastAnimStart = 0;
  
  subst!(abs, a, { a > 0: a, -1 * a });
  subst!(movingX, bool!(abs!(diff!(targetX, cameraX)) > 0.2));
  
  fn startCamera() {
    lastAnimStart -> { movingX!() > 0: lastAnimStart, global.frame }
  }
  
  fn adjustCameraToPlayer() {
    targetX -> -1 * player.x
      , cameraX -> global.lerp(cameraX, targetX, global.delta(lastAnimStart, 4000))
  }
}

ns player {
  row = 0;
  col = 0;
  
  x = col;
  y = gridSize - row;
  
  targetRow = row;
  targetCol = col;
  
  targetX = 0;
  targetY = gridSize;
  
  lastAnimStart = 0;
  
  show player = (
      cacheCos * (cos(t) * cos(t) + x)
      - cacheCos * (cos(t) * sin(t) + y)
      + camera.cameraX,
      cacheSin * (cos(t) * cos(t) + x)
      + cacheSin * (cos(t) * sin(t) + y)
      + camera.cameraY
      - 1
) @{ parametricDomain: @{ min: ds(-10), max: ds(10) } }
  
  fn movePlayer() {
    targetX -> targetCol
      , targetY -> gridSize - targetRow - 0.5
      , x -> global.lerp(x, targetX, global.delta(lastAnimStart, 60))
      , y -> global.lerp(y, targetY, global.delta(lastAnimStart, 60))
      , row -> targetRow
      , col -> targetCol
  }
}

ns controls {
  subst!(not, a, 1 - a);
  subst!(anim, player.lastAnimStart -> global.frame);
  
  show (-1, -1) @{
    clickableInfo: @{
      enabled: true,
      latex: ds(player.targetRow -> player.targetRow - not!(checkUp()) , anim!())
    }
  }
  show (-1, -2) @{
    clickableInfo: @{
      enabled: true,
      latex: ds(player.targetRow -> player.targetRow + not!(checkDown()) , anim!())
    }
  }
  show (-1.5, -1.5) @{
    clickableInfo: @{
      enabled: true,
      latex: ds(player.targetCol -> player.targetCol - not!(checkLeft())
          , anim!()
          , camera.startCamera())
    }
  }
  show (-0.5, -1.5) @{
    clickableInfo: @{
      enabled: true,
      latex: ds(player.targetCol -> player.targetCol + not!(checkRight())
          , anim!()
          , camera.startCamera())
    }
  }
  
  fn getCellIndex(row, col) {
    row * gridSize + col + 1
  }
  
  show fn getCellWalls(idx) {
    [
      walls.binary[(idx * 4 - 3)],
      walls.binary[(idx * 4 - 2)],
      walls.binary[(idx * 4 - 1)],
      walls.binary[(idx * 4)]
    ]
  } @{ hidden: true }
  
  fn checkUp() {
    { player.row > 0: getCellWalls(getCellIndex(player.row, player.col))[4], 1 }
  }
  fn checkDown() {
    {
      player.row < diff!(gridSize, 1): getCellWalls(getCellIndex(player.row, player.col))[2],
      1
    }
  }
  fn checkLeft() {
    { player.col > 0: getCellWalls(getCellIndex(player.row, player.col))[1], 1 }
  }
  fn checkRight() {
    {
      player.col < diff!(gridSize, 1): getCellWalls(getCellIndex(player.row, player.col))[3],
      1
    }
  }
}

subst!(param, x1, y1, x2, y2, (
      cacheCos * ((1 - t) * x1 + t * x2)
      - cacheCos * ((1 - t) * y1 + t * y2)
      + camera.cameraX,
      cacheSin * ((1 - t) * x1 + t * x2)
      + cacheSin * ((1 - t) * y1 + t * y2)
      + camera.cameraY
      - 1
));

subst!(paramd, x1, y1, x2, y2, offsetX, offsetY, (
      cacheCos * ((1 - t) * x1 + t * x2)
      - cacheCos * ((1 - t) * y1 + t * y2)
      + camera.cameraX
      + offsetX,
      cacheSin * ((1 - t) * x1 + t * x2)
      + cacheSin * ((1 - t) * y1 + t * y2)
      + camera.cameraY
      + offsetY
      - 1
));

ns grid {
  idx = [0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0];
  subst!(p, i, n, idx[(i * 4 - n)] * gridSize);
  
  show [param!(p!(i, 3), p!(i, 2), p!(i, 1), p!(i, 0)) for i=[1..16]] @{ color: "black" }
  
  show param!(0, 12, 0, 11) @{ color: "red" }
}

ns walls {
  subst!(
drawRow,
      rowIndex,
      startCol,
      length,
      param!(startCol, gridSize - rowIndex, startCol + length, gridSize - rowIndex)
    );
  
  subst!(
drawCol,
      colIndex,
      startRow,
      length,
      param!(colIndex, gridSize - startRow, colIndex, gridSize - startRow - length)
    );
  
  subst!(shiftRow, rowIndex, startCol, length, paramd!(
startCol,
        gridSize - rowIndex,
        startCol + length,
        gridSize - rowIndex,
        0,
        gridOffset * -1
      ));
  
  subst!(shiftCol, colIndex, startRow, length, paramd!(
colIndex,
        gridSize - startRow,
        colIndex,
        gridSize - startRow - length,
        0,
        gridOffset * -1
      ));
  
  binary = maze!();
  "[rowIndex, startCol, length, rowIndex, startCol, length, ...]"
  rows = consolidateRows!();
  cols = consolidateCols!();
  
  len = gridSize * gridSize * 4;
  
  show R = [drawRow!(rows[(i * 3 - 2)], rows[(i * 3 - 1)], rows[(i * 3)]) for
    i=[1..length!(rows)]
  ] @{ color: "rgb(68,13,75)" }
  
  show C = [drawCol!(cols[(i * 3 - 2)], cols[(i * 3 - 1)], cols[(i * 3)]) for
    i=[1..length!(cols)]
  ] @{ color: "rgb(68,13,75)" }
}
