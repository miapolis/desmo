import script "./maze.mjs"

settings @{
    viewport: @{ xmin: -18, ymin: -20, xmax: 19, ymax: 40 },
    showGrid: false,
    showXAxis: false,
    showYAxis: false,
    userLockedViewport: true
  }

gridSize = 12;
proj = 3.5;
gridOffset = 0.75;

black = rgb(0, 0, 0);
gray = rgb(200, 200, 200);

cacheCos = cos(proj / 6);
cacheSin = sin(proj / 6);

subst!(diff, a, b, a - b);
subst!(bool, v, { v: 1, 0 });
subst!(not, a, 1 - a);

ticker @{ handlerLatex: ds(gameLoopLatex!()), playing: true, open: true }

fn gameLoop(delta) {
  player.movePlayer() , camera.adjustCameraToPlayer() , global.tick(delta)
}

ns global {
  frame = 0;
  deltaTime = 0;
  
  fn lerp(a, b, time) {
    (1 - time * deltaTime / 16) * a + time * deltaTime / 16 * b
  }
  show fn delta(start, duration) {
    mod((frame - start), duration) / duration
  } @{ hidden: true }
  
  fn tick(elapsed) {
    frame -> frame + 1 , deltaTime -> elapsed
  }
}

ns camera {
  cameraX = 0;
  cameraY = 0;
  
  targetX = 0;
  targetY = 0;
  
  lastAnimStart = 0;
  
  subst!(abs, a, { a > 0: a, -1 * a });
  subst!(movingX, bool!(abs!(diff!(targetX, cameraX)) > 0.2));
  
  fn startCamera() {
    lastAnimStart -> { movingX!() > 0: lastAnimStart, global.frame }
  }
  
  fn adjustCameraToPlayer() {
    targetX -> -1 * player.x
      , cameraX -> global.lerp(cameraX, targetX, global.delta(lastAnimStart, 4000))
  }
}

ns player {
  row = 0;
  col = 0;
  
  x = col;
  y = gridSize - row;
  
  targetRow = row;
  targetCol = col;
  
  targetX = 0;
  targetY = gridSize;
  
  lastAnimStart = 0;
  
  fn movePlayer() {
    targetX -> targetCol
      , targetY -> gridSize - targetRow - 0.5
      , x -> global.lerp(x, targetX, global.delta(lastAnimStart, 60))
      , y -> global.lerp(y, targetY, global.delta(lastAnimStart, 60))
      , row -> targetRow
      , col -> targetCol
  }
}

ns controls {
  subst!(anim, player.lastAnimStart -> global.frame);
  
  fn getCellIndex(row, col) {
    row * gridSize + col + 1
  }
  
  show fn getCellWalls(idx) {
    [
      walls.binary[(idx * 4 - 3)],
      walls.binary[(idx * 4 - 2)],
      walls.binary[(idx * 4 - 1)],
      walls.binary[(idx * 4)]
    ]
  } @{ hidden: true }
  
  fn checkUp() {
    { player.row > 0: getCellWalls(getCellIndex(player.row, player.col))[4], 1 }
  }
  fn checkDown() {
    {
      player.row < diff!(gridSize, 1): getCellWalls(getCellIndex(player.row, player.col))[2],
      1
    }
  }
  fn checkLeft() {
    { player.col > 0: getCellWalls(getCellIndex(player.row, player.col))[1], 1 }
  }
  fn checkRight() {
    {
      player.col < diff!(gridSize, 1): getCellWalls(getCellIndex(player.row, player.col))[3],
      1
    }
  }
}

subst!(param, x1, y1, x2, y2, (
      cacheCos * ((1 - t) * x1 + t * x2)
      - cacheCos * ((1 - t) * y1 + t * y2)
      + camera.cameraX,
      cacheSin * ((1 - t) * x1 + t * x2)
      + cacheSin * ((1 - t) * y1 + t * y2)
      + camera.cameraY
      - 1
));

subst!(vert, x, y, length, (
      x * cacheCos - y * cacheCos + camera.cameraX,
      x * cacheSin + y * cacheSin - length * t - 1 + camera.cameraY
));

subst!(paramd, x1, y1, x2, y2, offsetX, offsetY, (
      cacheCos * ((1 - t) * x1 + t * x2)
      - cacheCos * ((1 - t) * y1 + t * y2)
      + camera.cameraX
      + offsetX,
      cacheSin * ((1 - t) * x1 + t * x2)
      + cacheSin * ((1 - t) * y1 + t * y2)
      + camera.cameraY
      + offsetY
      - 1
));

subst!(xy, xVar, yVar, (
      cacheCos * xVar - cacheCos * yVar + camera.cameraX,
      cacheSin * xVar + cacheSin * yVar + camera.cameraY - 1
));
subst!(shiftXy, xVar, yVar, offsetY, (
      cacheCos * xVar - cacheCos * yVar + camera.cameraX,
      cacheSin * xVar + cacheSin * yVar + camera.cameraY - 1 - offsetY
));

subst!(wall, x1, y1, x2, y2, polygon(
xy!(x1, y1),
      xy!(x2, y2),
      shiftXy!(x2, y2, gridOffset),
      shiftXy!(x1, y1, gridOffset)
    ));

ns walls {
  
  subst!(shiftRow, rowIndex, startCol, length, paramd!(
startCol,
        gridSize - rowIndex,
        startCol + length,
        gridSize - rowIndex,
        0,
        gridOffset * -1
      ));
  
  subst!(shiftCol, colIndex, startRow, length, paramd!(
colIndex,
        gridSize - startRow,
        colIndex,
        gridSize - startRow - length,
        0,
        gridOffset * -1
      ));
  
  binary = maze!();
  "[type, index, start, ...]"
}

ns renderer {
  ns background {
    show bg = polygon((-100, -100), (-100, 100), (100, 100), (100, -100)) @{ colorLatex: ds(rgb(3, 7, 18)), fillOpacity: ds(1) }
  }
  
  ns maze {
    show floor = polygon(
shiftXy!(0, 0, gridOffset),
        shiftXy!(gridSize, 0, gridOffset),
        shiftXy!(gridSize, gridSize, gridOffset),
        shiftXy!(0, gridSize, gridOffset)
      ) @{ colorLatex: ds(rgb(17, 24, 39)), fillOpacity: ds(1) }
  }
  
  ns walls {
    subst!(
polygonRow,
        rowIndex,
        startCol,
        wall!(startCol, gridSize - rowIndex, startCol + 1, gridSize - rowIndex)
      );
    
    subst!(
polygonCol,
        colIndex,
        startRow,
        wall!(colIndex, gridSize - startRow, colIndex, gridSize - startRow - 1)
      );
    
    subst!(
parametricRow,
        rowIndex,
        startCol,
        length,
        param!(startCol, gridSize - rowIndex, startCol + length, gridSize - rowIndex)
      );
    
    subst!(
parametricCol,
        colIndex,
        startRow,
        length,
        param!(colIndex, gridSize - startRow, colIndex, gridSize - startRow - length)
      );
    
    data = polygonData!();
    lines = parametricData!();
    
    wallTypes = [data[(i * 3 - 2)] for i=[1..length!(data) / 3]];
    "rgb( 31, 41, 55 )"
    "rgb( 55, 65, 81 )"
    colorR = [{ i == 0: 31, 55 } for i=wallTypes];
    colorG = [{ i == 0: 41, 65 } for i=wallTypes];
    colorB = [{ i == 0: 55, 81 } for i=wallTypes];
    colorLatex = rgb(colorR, colorG, colorB);
    
    show backRow = wall!(0, gridSize, gridSize, gridSize) @{ color: "rgb( 31, 41, 55 )", fillOpacity: "1" }
    show backCol = wall!(gridSize, 0, gridSize, gridSize) @{ color: "rgb( 55, 65, 81 )", fillOpacity: "1" }
    
    show polygons = [{
        data[(i * 3 - 2)] == 0: polygonRow!(data[(i * 3 - 1)], data[(i * 3)]),
        polygonCol!(data[(i * 3 - 1)], data[(i * 3)])
      } for i=[1..length!(data) / 3]] @{ color: "rgb(245,13,10)", fillOpacity: "1", colorLatex: ds(colorLatex) }
    
    ns character {
      show circle1 = (
          cacheCos * (cos(t) * cos(t) * 0.8 + player.x)
          - cacheCos * (cos(t) * sin(t) * 0.8 + player.y)
          + camera.cameraX,
          cacheSin * (cos(t) * cos(t) * 0.8 + player.x)
          + cacheSin * (cos(t) * sin(t) * 0.8 + player.y)
          + camera.cameraY
          - 1
) @{
        parametricDomain: @{ min: ds(0), max: ds(tau!()) },
        color: "red",
        lineWidth: "5"
      }
      
      show circle2 = (
          cacheCos * (cos(t) * cos(t) * 0.8 + player.x)
          - cacheCos * (cos(t) * sin(t) * 0.8 + player.y)
          + camera.cameraX,
          cacheSin * (cos(t) * cos(t) * 0.8 + player.x)
          + cacheSin * (cos(t) * sin(t) * 0.8 + player.y)
          + camera.cameraY
          - 1.75
) @{
        parametricDomain: @{ min: ds(0), max: ds(tau!()) },
        color: "red",
        lineWidth: "5"
      }
    }
    
    show parametrics = [{
        lines[(i * 4 - 3)] == 0: parametricRow!(lines[(i * 4 - 2)], lines[(i * 4 - 1)], lines[(i * 4)]),
        parametricCol!(lines[(i * 4 - 2)], lines[(i * 4 - 1)], lines[(i * 4)])
      } for
      i=[1..length!(lines) / 4]
    ] @{ color: "rgb(209, 213, 219)", fillOpacity: "1", lineWidth: "5" }
  }
  
  show frontRow = wall!(0, 0, gridSize, 0) @{ color: "rgb( 31, 41, 55 )", fillOpacity: "1" }
  show frontCol = wall!(0, 0, 0, gridSize) @{ color: "rgb( 55, 65, 81 )", fillOpacity: "1" }
  
  ns frame {
    idx = [0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0];
    subst!(p, i, n, idx[(i * 4 - n)] * gridSize);
    
    show [param!(p!(i, 3), p!(i, 2), p!(i, 1), p!(i, 0)) for i=[1..16]] @{ color: "rgb(209,213,219)", fillOpacity: "1", lineWidth: "5" }
  }
  
  ns controller {
    show (-1, -1) @{
      clickableInfo: @{
        enabled: true,
        latex: ds(player.targetRow -> player.targetRow - not!(controls.checkUp())
            , controls.anim!())
      },
      lineWidth: "5",
      color: "red"
    }
    show (-1, -2) @{
      clickableInfo: @{
        enabled: true,
        latex: ds(player.targetRow -> player.targetRow + not!(controls.checkDown())
            , controls.anim!())
      },
      lineWidth: "5",
      color: "red"
    }
    show (-1.5, -1.5) @{
      clickableInfo: @{
        enabled: true,
        latex: ds(player.targetCol -> player.targetCol - not!(controls.checkLeft())
            , controls.anim!()
            , camera.startCamera())
      },
      lineWidth: "5",
      color: "red"
    }
    show (-0.5, -1.5) @{
      clickableInfo: @{
        enabled: true,
        latex: ds(player.targetCol -> player.targetCol + not!(controls.checkRight())
            , controls.anim!()
            , camera.startCamera())
      },
      lineWidth: "5",
      color: "red"
    }
  }
}
