import script "./maze.mjs"

settings @{
    viewport: @{ xmin: -18, ymin: -20, xmax: 19, ymax: 40 },
    showGrid: false,
    showXAxis: false,
    showYAxis: false,
    userLockedViewport: true
  }

gridSize = 12;
proj = 3.5;
gridOffset = 0.75;

black = rgb(0, 0, 0);
gray = rgb(200, 200, 200);

cacheCos = cos(proj / 6);
cacheSin = sin(proj / 6);

subst!(diff, a, b, a - b);
subst!(sum, a, b, a + b);
subst!(bool, v, { v: 1, 0 });
subst!(not, a, 1 - a);

ticker @{ handlerLatex: ds(gameLoopLatex!()), playing: true, open: true }

fn gameLoop(delta) {
  player.movePlayer()
    , camera.adjustCameraToPlayer()
    , { global.frame < 130: controller.playAnim() }
    , global.tick(delta)
}

ns global {
  frame = 0;
  deltaTime = 0;
  
  fn lerp(a, b, time) {
    (1 - time * deltaTime / 16) * a + time * deltaTime / 16 * b
  }
  show fn delta(start, duration) {
    mod((frame - start), duration) / duration
  } @{ hidden: true }
  
  fn tick(elapsed) {
    frame -> frame + 1 , deltaTime -> elapsed
  }
}

ns camera {
  cameraX = 0;
  cameraY = 4;
  
  targetX = 0;
  targetY = 0;
  
  lastAnimStart = 0;
  
  subst!(abs, a, { a > 0: a, -1 * a });
  subst!(movingX, bool!(abs!(diff!(targetX, cameraX)) > 0.2));
  
  fn startCamera() {
    lastAnimStart -> { movingX!() > 0: lastAnimStart, global.frame }
  }
  
  fn adjustCameraToPlayer() {
    targetX -> -1 * player.x
      , cameraX -> global.lerp(cameraX, targetX, global.delta(lastAnimStart, 4000))
  }
}

ns player {
  row = 0;
  col = 0;
  
  respectiveIndex = row * gridSize + col + 1;
  
  x = col;
  y = gridSize - row;
  
  targetRow = row;
  targetCol = col;
  
  targetX = 0;
  targetY = gridSize;
  
  lastAnimStart = 0;
  
  fn movePlayer() {
    targetX -> targetCol
      , targetY -> gridSize - targetRow - 0.5
      , x -> global.lerp(x, targetX, global.delta(lastAnimStart, 60))
      , y -> global.lerp(y, targetY, global.delta(lastAnimStart, 60))
      , row -> round(global.lerp(row, targetRow, global.delta(lastAnimStart, 30)))
      , col -> round(global.lerp(col, targetCol, global.delta(lastAnimStart, 30)))
  }
}

ns controls {
  subst!(anim, player.lastAnimStart -> global.frame);
  
  fn getCellIndex(row, col) {
    row * gridSize + col + 1
  }
  
  show fn getCellWalls(idx) {
    [
      walls.binary[(idx * 4 - 3)],
      walls.binary[(idx * 4 - 2)],
      walls.binary[(idx * 4 - 1)],
      walls.binary[(idx * 4)]
    ]
  } @{ hidden: true }
  
  fn checkUp() {
    { player.row > 0: getCellWalls(getCellIndex(player.row, player.col))[4], 1 }
  }
  fn checkDown() {
    {
      player.row < diff!(gridSize, 1): getCellWalls(getCellIndex(player.row, player.col))[2],
      1
    }
  }
  fn checkLeft() {
    { player.col > 0: getCellWalls(getCellIndex(player.row, player.col))[1], 1 }
  }
  fn checkRight() {
    {
      player.col < diff!(gridSize, 1): getCellWalls(getCellIndex(player.row, player.col))[3],
      1
    }
  }
}

subst!(param, x1, y1, x2, y2, (
      cacheCos * ((1 - t) * x1 + t * x2)
      - cacheCos * ((1 - t) * y1 + t * y2)
      + camera.cameraX,
      cacheSin * ((1 - t) * x1 + t * x2)
      + cacheSin * ((1 - t) * y1 + t * y2)
      + camera.cameraY
      - 1
));

subst!(vert, x, y, length, (
      x * cacheCos - y * cacheCos + camera.cameraX,
      x * cacheSin + y * cacheSin - length * t - 1 + camera.cameraY
));

subst!(paramd, x1, y1, x2, y2, offsetX, offsetY, (
      cacheCos * ((1 - t) * x1 + t * x2)
      - cacheCos * ((1 - t) * y1 + t * y2)
      + camera.cameraX
      + offsetX,
      cacheSin * ((1 - t) * x1 + t * x2)
      + cacheSin * ((1 - t) * y1 + t * y2)
      + camera.cameraY
      + offsetY
      - 1
));

subst!(iso, xVar, yVar, yOffset, (
      cacheCos * xVar - cacheCos * yVar,
      cacheSin * xVar + cacheSin * yVar - 1 - yOffset
));
subst!(xy, xVar, yVar, (
      cacheCos * xVar - cacheCos * yVar + camera.cameraX,
      cacheSin * xVar + cacheSin * yVar + camera.cameraY - 1
));
subst!(shiftXy, xVar, yVar, offsetY, (
      cacheCos * xVar - cacheCos * yVar + camera.cameraX,
      cacheSin * xVar + cacheSin * yVar + camera.cameraY - 1 - offsetY
));

subst!(wall, x1, y1, x2, y2, polygon(
xy!(x1, y1),
      xy!(x2, y2),
      shiftXy!(x2, y2, gridOffset),
      shiftXy!(x1, y1, gridOffset)
    ));

ns walls {
  subst!(shiftRow, rowIndex, startCol, length, paramd!(
startCol,
        gridSize - rowIndex,
        startCol + length,
        gridSize - rowIndex,
        0,
        gridOffset * -1
      ));
  
  subst!(shiftCol, colIndex, startRow, length, paramd!(
colIndex,
        gridSize - startRow,
        colIndex,
        gridSize - startRow - length,
        0,
        gridOffset * -1
      ));
  
  binary = maze!();
  polyData = polygonData!();
  lineData = parametricData!();
}

ns renderer {
  ns background {
    show bg = polygon((-100, -100), (-100, 100), (100, 100), (100, -100)) @{ colorLatex: ds(rgb(3, 7, 18)), fillOpacity: ds(1) }
  }
  
  ns maze {
    show floor = polygon(
shiftXy!(0, 0, gridOffset),
        shiftXy!(gridSize, 0, gridOffset),
        shiftXy!(gridSize, gridSize, gridOffset),
        shiftXy!(0, gridSize, gridOffset)
      ) @{ colorLatex: ds(rgb(17, 24, 39)), fillOpacity: ds(1) }
  }
  
  ns obstacles {
    subst!(
polygonRow,
        rowIndex,
        startCol,
        wall!(startCol, gridSize - rowIndex, startCol + 1, gridSize - rowIndex)
      );
    
    subst!(
polygonCol,
        colIndex,
        startRow,
        wall!(colIndex, gridSize - startRow, colIndex, gridSize - startRow - 1)
      );
    
    subst!(
parametricRow,
        rowIndex,
        startCol,
        length,
        param!(startCol, gridSize - rowIndex, startCol + length, gridSize - rowIndex)
      );
    
    subst!(
parametricCol,
        colIndex,
        startRow,
        length,
        param!(colIndex, gridSize - startRow, colIndex, gridSize - startRow - length)
      );
    
    wallTypes = [walls.polyData[(i * 3 - 2)] for i=[1..length!(walls.polyData) / 3]];
    "rgb( 31, 41, 55 )"
    "rgb( 55, 65, 81 )"
    colorR = [{ i == 0: 31, 55 } for i=wallTypes];
    colorG = [{ i == 0: 41, 65 } for i=wallTypes];
    colorB = [{ i == 0: 55, 81 } for i=wallTypes];
    colorLatex = rgb(colorR, colorG, colorB);
    
    show backRow = wall!(0, gridSize, gridSize, gridSize) @{ color: "rgb( 31, 41, 55 )", fillOpacity: "1" }
    show backCol = wall!(gridSize, 0, gridSize, gridSize) @{ color: "rgb( 55, 65, 81 )", fillOpacity: "1" }
    
    subst!(type, i, walls.polyData[(i * 3 - 2)]);
    subst!(index, i, walls.polyData[(i * 3 - 1)]);
    subst!(start, i, walls.polyData[(i * 3)]);
    
    subst!(
debouncedRow,
        { player.targetRow > player.row: player.targetRow, player.row }
      );
    subst!(
debouncedCol,
        { player.targetCol < player.col: player.targetCol, player.col }
      );
    
    fn getRearPolygon(i) {
      {
        type!(i) == 0: {
          (bool!(index!(i) <= debouncedRow!()) * bool!(start!(i) >= debouncedCol!())) == 1: polygonRow!(index!(i), start!(i))
        },
        (bool!(index!(i) > debouncedCol!()) * bool!(start!(i) <= debouncedRow!())) == 1: polygonCol!(index!(i), start!(i))
      }
    }
    fn getFrontPolygon(i) {
      {
        type!(i) == 0: {
          (bool!(index!(i) <= debouncedRow!()) * bool!(start!(i) >= debouncedCol!())) == 0: polygonRow!(index!(i), start!(i))
        },
        (bool!(index!(i) > debouncedCol!()) * bool!(start!(i) <= debouncedRow!())) == 0: polygonCol!(index!(i), start!(i))
      }
    }
    
    show rearPolygons = [getRearPolygon(i) for i=[1..length!(walls.polyData) / 3]] @{ fillOpacity: "1", colorLatex: ds(colorLatex), lines: false }
    
    ns character {
      subst!(circle, offset, size, (
            cacheCos * (cos(t) * cos(t) * size + player.x + (1 - size) / 2)
            - cacheCos * (cos(t) * sin(t) * size + player.y)
            + camera.cameraX,
            cacheSin * (cos(t) * cos(t) * size + player.x)
            + cacheSin * (cos(t) * sin(t) * size + player.y)
            + camera.cameraY
            - 1
            - offset
));
      
      show circle3 = circle!(gridOffset - 0.1, 0.4) @{
        parametricDomain: @{ min: ds(0), max: ds(tau!()) },
        color: "rgb(245, 158, 11)",
        lineWidth: "5",
        lineOpacity: "0.5"
      }
      show circle2 = circle!((gridOffset - 0.1) / 2, 0.6) @{
        parametricDomain: @{ min: ds(0), max: ds(tau!()) },
        color: "rgb(249, 115, 22)",
        lineWidth: "5",
        lineOpacity: "0.75"
      }
      show circle1 = circle!(0, 0.8) @{
        parametricDomain: @{ min: ds(0), max: ds(tau!()) },
        color: "rgb(239, 68, 68)",
        lineWidth: "5",
        lineOpacity: "1"
      }
    }
    
    show frontPolygons = [getFrontPolygon(i) for i=[1..length!(walls.polyData) / 3]] @{ fillOpacity: "1", colorLatex: ds(colorLatex), lines: false }
    
    show parametrics = [{
        walls.lineData[(i * 4 - 3)] == 0: parametricRow!(
walls.lineData[(i * 4 - 2)],
            walls.lineData[(i * 4 - 1)],
            walls.lineData[(i * 4)]
          ),
        parametricCol!(
walls.lineData[(i * 4 - 2)],
            walls.lineData[(i * 4 - 1)],
            walls.lineData[(i * 4)]
          )
      } for i=[1..length!(walls.lineData) / 4]] @{ color: "rgb(209, 213, 219)", fillOpacity: "1", lineWidth: "5" }
  }
  
  show frontRow = wall!(0, 0, gridSize, 0) @{ color: "rgb( 31, 41, 55 )", fillOpacity: "1" }
  show frontCol = wall!(0, 0, 0, gridSize) @{ color: "rgb( 55, 65, 81 )", fillOpacity: "1" }
  
  ns frame {
    idx = [0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0];
    subst!(p, i, n, idx[(i * 4 - n)] * gridSize);
    
    show [param!(p!(i, 3), p!(i, 2), p!(i, 1), p!(i, 0)) for i=[1..16]] @{ color: "rgb(209,213,219)", fillOpacity: "1", lineWidth: "5" }
  }
}

ns controller {
    fn xRotate(x, y, angle) {
      x * cos(angle) - y * sin(angle)
    }
    fn yRotate(x, y, angle) {
      x * sin(angle) + y * cos(angle)
    }
    
    buttonWidth = 0.5;
    buttonScale = 1.5;
    buttonHeight = 1.5;
    buttonDistance = 0.5;
    
    show verts = [
      (0, 0),
      (buttonWidth, 0.5),
      (buttonWidth, buttonHeight),
      (-1 * buttonWidth, buttonHeight),
      (-1 * buttonWidth, 0.5)
    ] @{ hidden: true }
    
    subst!(
rX,
        angle,
        xRotate(verts.x * buttonScale, verts.y * buttonScale + buttonDistance, angle)
      );
    subst!(
rY,
        angle,
        yRotate(verts.x * buttonScale, verts.y * buttonScale + buttonDistance, angle)
      );
    
    subst!(
button,
        angle,
        animOffset,
        polygon(iso!(rX!(angle), rY!(angle), animOffset))
      );
    
    topOffset = 2;
    bottomOffset = 2;
    rightOffset = 2;
    leftOffset = 2;

    upEnabled = not!(controls.checkUp());
    downEnabled = not!(controls.checkDown());
    rightEnabled = not!(controls.checkRight());
    leftEnabled = not!(controls.checkLeft());
    
    fn mix(a, b, factor) {
      show clampedFactor = min(max(factor, 0), 1) @{ hidden: true }
      b * clampedFactor + a * (1 - clampedFactor)
    }

    show fn easeInOutCubic(t) {
      { t < 0.5: 4 * t * t * t, 1 - (-2 * t + 2)^3 / 2}
    } @{ hidden: true }
     
    fn smoothstepMix(a, b, factor) {
      mix(a, b, factor * factor * (3 - factor * 2))
    }

    fn easeOutMix(a, b, factor) {
      mix(a, b, easeInOutCubic(factor))
    }

    subst!(delay, expr, frames, duration, { global.frame > frames: { global.frame < sum!(frames, duration): expr } });
    
    fn playAnim() {
      rightOffset -> delay!(easeOutMix(2, 0, global.delta(0, 100)), 0, 100),
      topOffset -> delay!(easeOutMix(2, 0, global.delta(10, 100)), 10, 100),
      leftOffset -> delay!(easeOutMix(2, 0, global.delta(20, 100)), 20, 100),
      bottomOffset -> delay!(easeOutMix(2, 0, global.delta(30, 100)), 30, 100)
    }
    
    show button!(0, topOffset) @{
      clickableInfo: @{
        enabled: true,
        latex: ds(player.targetRow -> player.targetRow - upEnabled
            , controls.anim!())
      },
      lineOpacity: ds((2 - topOffset) / 2 * upEnabled),
      fillOpacity: ds((2 - topOffset) / 2 * 0.4),
      lineWidth: "5",
      color: "red"
    }
    show button!(3.1416, bottomOffset) @{
      clickableInfo: @{
        enabled: true,
        latex: ds(player.targetRow -> player.targetRow + downEnabled
            , controls.anim!())
      },
      lineOpacity: ds((2 - bottomOffset) / 2 * downEnabled),
      fillOpacity: ds((2 - bottomOffset) / 2 * 0.4),
      lineWidth: "5",
      color: "red"
    }
    show button!(4.7124, rightOffset) @{
      clickableInfo: @{
        enabled: true,
        latex: ds(player.targetCol -> player.targetCol + rightEnabled
            , controls.anim!()
            , camera.startCamera())
      },
      lineOpacity: ds((2 - rightOffset) / 2 * rightEnabled),
      fillOpacity: ds((2 - rightOffset) / 2 * 0.4),
      lineWidth: "5",
      color: "red"
    }
    show button!(1.5708, leftOffset) @{
      clickableInfo: @{
        enabled: true,
        latex: ds(player.targetCol -> player.targetCol - leftEnabled
            , controls.anim!()
            , camera.startCamera())
      },
      lineOpacity: ds((2 - leftOffset) / 2 * leftEnabled),
      fillOpacity: ds((2 - leftOffset) / 2 * 0.4),
      lineWidth: "5",
      color: "red"
    }
  }
